# Kafka 탄생
LinkedIn은 서비스가 확장됨에 따라 소스 애플리케이션과 타겟 애플리케이션의 수가 급증하면서, 데이터 전송 라인이 기하급수적으로 복잡해졌음.
이러한 문제를 해결하기 위해, 내부 데이터 흐름을 중앙에서 관리하고 처리할 수 있는 특화된 솔루션이 필요하게 되었고, 그 결과로 탄생한 것이 Kafka.

LinkedIn에서는 Kafka를 개발하기 이전에 다양한 기존의 메시징 시스템을 적용하였지만, LinkedIn의 요구사항을 충족하기는 어려웠으며 이에 대응되는 Kafka의
특징으로 아래 내용을 책에서 소개한다. 

<br/>
<br/>

## Kafka의 중앙배치에 의한 서버간의 decoupling
기존 source application에서 target application으로 데이터를 직접적으로 전송하는 방식은 두 서버간의 결합도를 높이면서, 서비스 확장에 따라 데이터 전송 라인이 급증하는 단점이 부각되었다.
<br/>
Kafka가 중앙에 배치됨으로써 기존의 source와 target은 단순히 producer와 consumer로 역할을 한다. 이러한 구조는 두 서버간의 결합도를 완화시킨다. 
<img width="1155" alt="스크린샷 2024-11-12 오후 10 17 10" src="https://github.com/user-attachments/assets/685addff-2b6e-41ea-856a-3f5591a5fea8">

---
<br/>
<br/>

## Kafka message data format
Kafka를 통해 전달할 수 있는 data format은 사실 상 제한이 없다. 직렬화, 역직렬화를 통해 ByteArray로 통신하기 때문이다.

---
<br/>
<br/>

## 높은 처리량
Kafka에서는 메시지 전송 시 batch 단위로 전송함으로써 RTT를 줄일 수 있다. 또한 동일 목적의 데이터를 여러 파티션에 분배하고 컨슈머 개수를 늘려 병렬처리함으로써 동일 시간당 데이터 처리량을 늘릴 수 있다.

<img width="777" alt="스크린샷 2024-11-12 오후 10 36 29" src="https://github.com/user-attachments/assets/b38ac6ac-dc92-4507-a26f-cf815f526cb0">
---
<br/>
<br/>

## 확장성

- Kafka는 브로커의 Scale-Out 및 Scale-In을 통해 클러스터를 구성할 수 있다. 이를 통해 다양한 트래픽 상황에 유연하게 대처 가능하다.
- 트래픽이 몰리는 상황에서도 안정적으로 확장이 가능하다.
- 클러스터는 무중단 운영을 지원한다.

---

## 영속성

- Kafka는 데이터를 메모리가 아닌 파일 시스템에 저장하며, 이를 통해 데이터를 안전하게 관리한다.

### 파일 시스템 기반 데이터 저장

- 일반적으로 파일 시스템 저장은 느리다고 여겨지지만, Kafka는 OS 수준에서 파일 시스템을 최적화하여 활용한다.
- 페이지 캐시를 통해 메모리에서 파일 내용을 캐싱하고 재사용하여 높은 처리량을 유지한다.

### 장애 복구 지원

- 디스크 기반 저장 방식 덕분에 브로커 장애가 발생해도 데이터를 안전하게 복구할 수 있다.

---

## 고가용성

- Kafka는 데이터 복제를 통해 고가용성을 제공한다.
- 클러스터는 3개 이상의 브로커로 구성해야 높은 신뢰성과 지속적인 데이터 처리가 가능하다.
- 프로듀서로 전송된 데이터는 여러 브로커에 복제되어 저장된다.
- 브로커 장애 시에도 복제된 데이터를 가진 다른 브로커가 역할을 대체하여 무중단 운영이 가능하다.

---

## Kafka 클러스터를 3대 이상의 브로커로 구성해야 하는 이유

Kafka에서 고가용성을 보장하기 위해 **min.insync.replicas** 옵션을 설정한다.

### min.insync.replicas 옵션

- 파티션 리더와 동기화 상태를 유지하는 복제본의 최소 개수를 설정하는 옵션으로, 데이터 일관성을 보장하고 데이터 유실을 방지한다.

### 예시

- **min.insync.replicas=2**로 설정한 경우, 최소 2개의 브로커에 데이터가 복제되어야 쓰기 작업이 가능하다.
- 클러스터에 옵션값보다 적은 수의 브로커만 존재하면 쓰기 작업이 불가능하다.
- 브로커 하나에 장애가 발생해도 지속적으로 데이터를 처리하려면 최소 3대 이상의 브로커를 사용하는 것이 필요하다.

### 설정 예시

```
# server.properties 파일에 추가
min.insync.replicas=2
```



