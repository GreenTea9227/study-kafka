# 토픽과 파티션

## 토픽(Topic)

Kafka에서 데이터를 구분하기 위한 단위.

### 주요 특징

- **파티션 소유**

  하나의 토픽은 1개 이상의 파티션으로 구성되며, 파티션은 데이터를 저장하는 기본 단위.

- **레코드 저장**

  파티션에는 프로듀서가 보낸 데이터인 레코드(record)가 저장됨.

- **병렬 처리**

  파티션은 Kafka 병렬 처리의 핵심. 컨슈머 그룹이 레코드를 병렬로 처리하도록 매칭되며, 컨슈머의 Scale-Out과 파티션 개수 증가를 통해 처리량을 높일 수 있음.

- **큐와 유사한 구조**

  파티션은 큐와 비슷하지만, Kafka에서는 데이터를 가져가도 삭제하지 않음. 파티션의 레코드는 컨슈머가 가져가는 것과 별개로 관리되기 때문에 다양한 목적을 가진 여러 컨슈머 그룹이 동일한 데이터를 여러 번 가져갈 수 있음.


---

### 토픽 이름 제약 조건

1. 빈 문자열 사용 불가.
2. 마침표 하나(`.`) 또는 마침표 둘(`..`) 사용 불가.
3. 이름 길이는 249자 미만이어야 함.
4. 사용 가능한 문자:
    - 영어 대소문자 (`A-Z`, `a-z`)
    - 숫자 (`0-9`)
    - 마침표(`.`), 언더바(`_`), 하이픈(``)
5. 아래 내부 관리용 토픽 이름은 생성 불가:
    - `__consumer_offsets`
    - `__transaction_state`
6. 마침표(`.`)와 언더바(`_`)가 동시에 포함된 이름은 생성 가능하지만 경고 메시지 발생 가능.
7. 기존 토픽 이름과 혼동될 수 있는 이름 생성 불가:
    - 예: `to.pic` 이름의 토픽이 이미 존재하면 `to_pic`은 생성 불가.

---

### 토픽 이름 작성 시 유의사항

1. 이름만으로 개발 환경, 어플리케이션, 데이터 타입을 유추할 수 있어야 함.
2. 공용 Kafka를 사용하는 경우, 소유 팀 이름을 토픽 이름에 포함하는 것을 고려.
3. 토픽 이름 규칙을 미리 정의하고 이를 팀원이 따르도록 해야 함.
4. Kafka는 토픽 이름 변경을 지원하지 않으므로, 이름 변경이 필요하면 삭제 후 재생성해야 함.

---

## 레코드(Record)

Kafka의 데이터 단위인 레코드는 다음과 같은 구성 요소로 이루어져 있음.

### 레코드 구성 요소

1. **timestamp**
    - 프로듀서가 레코드를 생성한 시점의 유닉스 타임 값.
    - 프로듀서가 지정하지 않을 경우, 브로커의 적재 시간(`LogAppendTime`)으로 설정됨.
2. **key**
    - 메시지 키는 데이터를 특정 파티션에 저장하거나 메시지 값을 분류하는 데 사용됨.
    - 동일한 메시지 키는 동일한 파티션에 저장되지만, 파티션 개수가 변경되면 매칭이 달라질 수 있음.
    - 메시지 키가 없는 경우 `null`로 설정되며, 프로듀서 기본 파티셔너가 데이터 분배를 수행함.
3. **value**
    - 메시지의 실제 데이터가 포함된 필드.
    - 직렬화된 형태로 전송되며, 컨슈머가 데이터를 사용할 때 역직렬화를 수행해야 함.
4. **offset**
    - 레코드의 고유 식별자로, 이전 레코드의 offset 값 +1로 자동 생성됨.
    - 컨슈머가 데이터를 가져간 위치를 추적하는 데 사용됨.
5. **header**
    - 레코드에 추가적인 정보를 저장하는 메타데이터 필드.
    - 키/값 형태로 데이터를 저장하며, 컨슈머가 이를 참조하여 처리할 수 있음.

---

### 레코드 저장 및 삭제

- 브로커에 저장된 레코드는 수정 불가하며, 로그 리텐션 정책(기간 또는 용량)에 따라 삭제됨.
- 한 번 저장된 레코드는 다양한 컨슈머가 독립적으로 데이터를 처리할 수 있음.